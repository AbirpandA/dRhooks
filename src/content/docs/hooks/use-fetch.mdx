---
title: "useFetch"
description: "A type-safe React hook that fetches data using axios with built-in loading, error, abort, and refetch capabilities."
---

<Tabs items={["CLI","Manual"]} className="pt-5 bg-transparent">
  <Tab>
    ```npm
    npx shadcn@latest add https://dr-hooks.vercel.app/r/use-fetch.json
    ```
  </Tab>
  <Tab>
    <ComponentSource name="use-fetch" />
  </Tab>
</Tabs>

### Dependencies

This hook depends on:

- `axios` (for HTTP requests and cancellation support)

Install:

```npm
npm install axios
```

---

## Overview

`useFetch` is a small, type-safe React hook that wraps an axios GET request and exposes common request state: `data`, `error`, `loading`, and a `refetch` method. It automatically aborts previous requests when the URL or config changes and supports manual refetching.

### What It Does

- Performs an HTTP GET using `axios.get<T>(url, config)`
- Returns a typed `data` value, an `AxiosError` (if any), a `loading` boolean, and a `refetch` function
- Uses an internal `AbortController` so in-flight requests are cancelled when the hook re-runs or the component unmounts

### When to Use It

Use `useFetch` when you need a lightweight data fetching hook with built-in cancellation and simple state management. Common scenarios:

- Fetching resource data for list/detail views
- Simple data-driven components where you prefer hook-level fetch management over a full data-fetching library
- Quick prototypes and internal tools

---

## Usage

### Basic Usage

```tsx
"use client"
// [!code highlight]
import { useFetch } from "@/registry/new-york/hooks/use-fetch";

function PostViewer({ id }: { id: number }) {
  // [!code focus]
  // [!code focus] 1. Initialize the hook with your API endpoint
  const { data, loading, error, refetch } = useFetch<Post>(
    `https://jsonplaceholder.typicode.com/posts/${id}`
  );

  // [!code focus]
  // [!code focus] 2. Handle loading state
  if (loading) return <div>Loading...</div>;
  // [!code focus]
  // [!code focus] 3. Handle error state
  if (error) return <div>Error: {error.message}</div>;

  return (
    <article>
      <h3>{data?.title}</h3>
      <p>{data?.body}</p>
      {/* [!code highlight] 4. Use refetch to manually trigger a new request */}
      <button onClick={refetch}>Refetch</button>
    </article>
  );
}

interface Post {
  userId: number;
  id: number;
  title: string;
  body: string;
}

```
### Advanced Example

Customize the axios request via the `config` parameter (headers, params, etc.) and handle loading state for UI feedback.

```tsx
import { useFetch } from "@/registry/new-york/hooks/use-fetch";

function Comments({ postId }: { postId: number }) {
  const { data, loading } = useFetch<Comment[]>(
    `https://jsonplaceholder.typicode.com/posts/${postId}/comments`,
    { params: { _limit: 10 } }
  );

  return (
    <div>
      {loading ? <span>Loading...</span> : null}
      <ul>
        {data?.map((c) => (
          <li key={c.id}>{c.email}: {c.body}</li>
        ))}
      </ul>
    </div>
  );
}

type Comment = {
  postId: number;
  id: number;
  name: string;
  email: string;
  body: string;
};
```

---

## API Reference

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `url` | `string` | Yes | The URL to fetch. Changing the URL triggers an automatic refetch. |
| `config` | `AxiosRequestConfig` | No | Optional axios request config (headers, params, etc.). |

<Callout type="warning">
  The hook will re-run whenever the `url` or `config` reference changes. To avoid accidental refetch loops, memoize `config` (and any complex headers/params) with `useMemo`.
  Check the Troubleshooting section for details.
</Callout>

### Return Value

| Value | Type | Description |
|-------|------|-------------|
| `data` | `T | null` | The fetched data, or `null` if not available. |
| `error` | `AxiosError | null` | The axios error object when the request fails, or `null`. |
| `loading` | `boolean` | `true` while the request is in-flight. |
| `refetch` | `() => void` | Function to manually re-run the request with the current `url` and `config`. |

---

## Key Concepts

### Abort & Cancellation

`useFetch` creates an `AbortController` for each request. When the URL or config changes (or the component unmounts), the in-flight request is aborted to avoid race conditions and wasted work.

Axios is called with the `signal` option so the native AbortController is used. The hook ignores cancellation errors and surfaces only real network or response errors to `error`.

### Typed Responses

The hook is generic and preserves the response type `T`. Use `useFetch<MyType>(url)` to get strongly-typed `data`.

### Refetching

Call the returned `refetch()` to programmatically trigger the request again without changing the `url` or `config`.

---

## Common Patterns

### Pattern 1: Pagination or Parameter Changes

Update the `url` (or include query params in `config.params`) when the page or filter changes. `useFetch` will automatically fetch the new resource.

### Pattern 2: Manual Refresh

Use the `refetch` method to refresh data after user-driven actions.

### Pattern 3: Error Handling

Check `error` to show friendly UI messages and retry affordances.

---

## Best Practices

<Callout>
  Use these tips to keep network usage efficient and UX smooth.
</Callout>

<Steps>
  <Step>
    <strong>Memoize URL/config when possible</strong>
    <p>Construct stable `url` strings and `config` objects to avoid unnecessary refetches (e.g., use `useMemo` for complex params).</p>
  </Step>

  <Step>
    <strong>Handle errors gracefully</strong>
    <p>Show user-friendly messages and provide retry options using `refetch`.</p>
  </Step>

  <Step>
    <strong>Keep side effects minimal</strong>
    <p>Do not perform heavy synchronous work in response to every successful fetch; batch or debounce UI updates when needed.</p>
  </Step>
</Steps>

---
## Troubleshooting

### 1. Automatic Re-fetching

The hook's `useEffect` is dependent on the `fetchData` callback, which itself is memoized with `useCallback`. This callback's dependencies are `[url, config]`.

This means the hook will **automatically** cancel any pending request and start a new one if the `url` string or the `config` object changes between renders.

### 2. Memoizing the `config` Object

If you provide the optional `config` object, you **must memoize it** with `useMemo`.

**Why?** If you create the `config` object inline (e.g., `useFetch(url, { headers: {...} })`), a new object reference is created on *every render*. The hook will see this as a change in its dependencies and trigger a new fetch, leading to an **infinite loop**.

**Correct Way (with `useMemo`):**


```tsx
import { useMemo } from 'react';
import { useFetch } from "@/hooks/use-fetch";

function UserDetails({ token }) {
  // [!code focus] Memoize the config object
  const config = useMemo(() => ({ 
    headers: { 'Authorization': `Bearer ${token}` } // [!code focus]
  }), [token]);  // [!code focus] Only re-create the object if the token changes

  const { data } = useFetch('/api/me', config);

  // ...
}
```



### Network errors or CORS

If requests fail due to CORS or network configuration, inspect the browser network tab and your server CORS settings.

### Request always cancelled

If `loading` never resolves, ensure you're not unintentionally changing `url` or `config` on every render.

---

## Technical Details

<Callout>
  Implementation notes: the hook uses `axios.get<T>(url, { ...config, signal })`, an `AbortController` stored in a ref, and `useCallback`/`useEffect` to manage the lifecycle.
</Callout>

- Built with TypeScript and axios
- Uses native AbortController for cancellation
- Returns a simple, stable API shape for UI consumption

---

## Related Hooks

- **useAsync / useMutation**: For mutating data (POST/PUT/DELETE) with more control over request lifecycle
- **useSWR / react-query**: Full-featured data fetching and caching libraries for complex needs
- **useFetch (this hook)**: Lightweight, no-cache, abort-capable fetch hook

---

If you'd like, I can also add a small example page under `src/registry/new-york/examples` that demonstrates combined usage with retry UI and error toasts.
