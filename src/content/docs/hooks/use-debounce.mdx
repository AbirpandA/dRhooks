---
title: "useDebounce"
description: " A type-safe React hook for debouncing rapidly changing values, perfect for search inputs, form validation, and API calls optimization."
---
<Tabs items={["Preview","Code"]}>
  <Tab>
    <ComponentPreview name="use-debounce-demo"/>
  </Tab>
  <Tab>
    <ComponentSource name="use-debounce"/>
  </Tab>
</Tabs>

## Installation

<Tabs items={["CLI","Manual"]} className="pt-5 bg-transparent">
  <Tab>
    ```npm
    npx shadcn@latest add https://dr-hooks.vercel.app/r/use-debounce.json
    ```
  </Tab>
  <Tab>
    <ComponentSource name="use-debounce" />
  </Tab>
</Tabs>

### Dependencies

This hook has **no external dependencies** and only uses built-in React APIs:
- `useState`
- `useEffect`

---

## Overview

useDebounce is a custom React hook that helps control the rate at which a rapidly changing value updates your application. It's particularly useful for optimizing performance in scenarios where you want to delay processing until after a user has finished their input or action.

### What It Does

The hook takes a value and a delay time (in milliseconds), then returns a debounced version of that value that only updates after the specified delay has passed without any new changes. This effectively reduces the frequency of updates and subsequent operations like API calls or heavy computations.

### When to Use It

This hook is ideal for:

- **Search Inputs**: Delay API calls until user stops typing
- **Form Validation**: Prevent excessive validation checks while typing
- **Window Resize Handlers**: Limit resize event processing
- **API Call Optimization**: Reduce unnecessary network requests

<Callout type="warning">
  **Performance Note**: While debouncing helps reduce processing frequency, setting extremely short delays (< 50ms) may not provide meaningful benefits.
</Callout>

---

## Usage

### Basic Example

```tsx
import { useDebounce } from "@/hooks/use-debounce";

function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearch = useDebounce(searchTerm, 300);

  useEffect(() => {
    // This effect will only run 300ms after the user stops typing
    searchAPI(debouncedSearch);
  }, [debouncedSearch]);

  return (
    <input
      type="text"
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

### Advanced Example

```tsx
import { useDebounce } from "@/hooks/use-debounce";

interface SearchResult {
  id: string;
  title: string;
}

function SearchWithFeedback() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<SearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  
  // Debounce the search query with 500ms delay
  const debouncedQuery = useDebounce(query, 500);

  useEffect(() => {
    async function searchData() {
      if (debouncedQuery.length < 3) return;
      
      setIsSearching(true);
      try {
        const data = await fetchSearchResults(debouncedQuery);
        setResults(data);
      } finally {
        setIsSearching(false);
      }
    }

    searchData();
  }, [debouncedQuery]);

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search (debounced)"
      />
      {isSearching && <span>Searching...</span>}
      <ul>
        {results.map(result => (
          <li key={result.id}>{result.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

## API Reference

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `value` | `T` | Yes | **Required.** The value to debounce. Can be of any type. |
| `delay` | `number` | No | **Optional.** Time in milliseconds to wait before updating the debounced value. Defaults to 300ms. |

### Return Value

The hook returns a debounced version of the input value:

| Value | Type | Description |
|-------|------|-------------|
| `debouncedValue` | `T` | The debounced value, which updates only after the specified delay has passed without new changes. |

---

## Key Concepts

### 1. Debouncing

Debouncing is a programming practice that limits the rate at which a function can fire. It ensures that time-consuming tasks don't fire so often that they hurt performance.

**Example:**
```tsx
// Without debouncing - API called on every keystroke
onChange={(e) => searchAPI(e.target.value)}

// With debouncing - API called only after typing stops
const debouncedValue = useDebounce(searchTerm, 300);
useEffect(() => searchAPI(debouncedValue), [debouncedValue]);
```

### 2. Cleanup

The hook performs proper cleanup by clearing timeouts when the component unmounts or when the value/delay changes.

**Why It Matters:**
- Prevents memory leaks
- Ensures accurate timing
- Handles rapid value changes correctly

### 3. Type Safety

The hook is fully typed and preserves the type of the input value.

**Technical Details:**
```tsx
function useDebounce<T>(value: T, delay?: number): T;
```

---

## Common Patterns

### Pattern 1: Search Input

```tsx
function SearchInput() {
  const [term, setTerm] = useState("");
  const debouncedTerm = useDebounce(term, 500);

  useEffect(() => {
    if (debouncedTerm) {
      performSearch(debouncedTerm);
    }
  }, [debouncedTerm]);

  return <input onChange={e => setTerm(e.target.value)} />;
}
```

**When to use**: For search interfaces where you want to reduce API calls

### Pattern 2: Form Validation

```tsx
function ValidatedInput() {
  const [value, setValue] = useState("");
  const debouncedValue = useDebounce(value, 400);
  const [error, setError] = useState("");

  useEffect(() => {
    validateInput(debouncedValue).then(setError);
  }, [debouncedValue]);

  return (
    <>
      <input onChange={e => setValue(e.target.value)} />
      {error && <span>{error}</span>}
    </>
  );
}
```

**Benefits**: Smoother user experience with delayed validation

---

## Best Practices

<Callout>
  Following these practices ensures optimal usage of the useDebounce hook.
</Callout>

### Do's

- ✅ **Choose Appropriate Delay**: Use longer delays (300-500ms) for API calls, shorter (150-250ms) for UI updates
- ✅ **Handle Initial Value**: Consider if you need immediate processing of the initial value
- ✅ **Type Your Data**: Leverage TypeScript generics for type safety

### Don'ts

- ❌ **Don't Debounce Critical Updates**: Avoid debouncing immediate feedback needs
- ❌ **Don't Use Too Short Delays**: Delays under 50ms usually don't provide meaningful benefits
- ❌ **Don't Ignore Cleanup**: Always ensure the component using the hook can unmount cleanly

---

## Advanced Usage

### Custom Equality Comparison

```tsx
function useCustomDebounce<T>(
  value: T,
  delay: number,
  isEqual: (prev: T, next: T) => boolean
) {
  const debouncedValue = useDebounce(value, delay);
  return useMemo(
    () => debouncedValue,
    [debouncedValue, isEqual]
  );
}
```

---

## Performance Considerations

- **Memory Usage**: The hook maintains minimal state (just the debounced value)
- **Timer Management**: Efficiently handles timer cleanup
- **When to be careful**: 
  - With very frequent updates (e.g., mouse move events)
  - When debouncing large data structures

---

